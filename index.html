<!DOCTYPE html>
<!-- dieses kleine Tool laedt ein GLB Modell, umgibt es optional mit einer Box  -->
<!-- V1.0 (C)JoEmbedded -->
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>3D-Viewer</title>
    <style>
        #viewer {
            width: 90vw;
            height: 80vh;
            border: 1px solid #ccc;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
        }

        #loader {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 150%;
            background: rgba(92, 91, 91, 0.9);
            padding: 1em 2em;
        }

        body {
            box-sizing: border-box;
            background: #222;
            color: #eee;
            font-family: sans-serif;
        }
    </style>
    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@latest/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
				}
			}
	</script>
</head>

<body>
    <h2>3D-Viewer - JoEmbedded</h2>
    <div id="loader">Lade Modell...</div>
    <div id="viewer"></div>

    <script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. Grundszene aufsetzen
        const container = document.getElementById('viewer');
        const scene = new THREE.Scene();

        // Funktion: Erzeuge einfarbiges Canvas Textur
        function createCanvasTexture(colorTop, colorBottom) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            // Farbverlauf (oben -> unten)
            const gradient = context.createLinearGradient(0, 0, 0, size);
            gradient.addColorStop(0, colorTop);
            gradient.addColorStop(1, colorBottom);
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }
        const bkTexture = createCanvasTexture('#ffffff', '#202030');
        bkTexture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = bkTexture;
        //scene.background = bkTexture; // kind of "Sky"
        scene.background = new THREE.Color(0x202028); // better

        const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000);
        const camTarget = new THREE.Vector3(0, 2, 0.5);
        camera.position.set(-1, 0.5, 2);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        //renderer.setSize(window.innerWidth, window.innerHeight); // variable size
        renderer.setSize(container.clientWidth-2, container.clientHeight-2);
        renderer.setAnimationLoop(animate);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMappingExposure = 1.2;
        renderer.toneMapping = THREE.LinearToneMapping;
        container.appendChild(renderer.domElement);
        window.addEventListener('resize', () => {
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        });

        // 3. GLTF/GLB laden
        let model;
        let targetscale;
        let modelscale;
        const loader = new GLTFLoader();
        const loaderDiv = document.getElementById('loader');
        loader.load(
            'rak3172sip.glb',
            (gltf) => {
                model = gltf.scene;

                // Mittelpunkt berechnen und verschieben
                const box = new THREE.Box3().setFromObject(model);
                const center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center);
                // Modell skalieren, sodass es einigermassen den Viewer füllt
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const desiredSize = 1.3; /* Default-Size fürs Test-Model, kann man noch optimieren */
                targetscale = desiredSize / maxDim;
                scene.add(model);
                modelscale = Math.max(model.scale.x, model.scale.y, model.scale.z);

                // Ausgabe Box in der Konsole
                console.log('BoundingBox min:', box.min);
                console.log('BoundingBox max:', box.max);
                console.log('Size:', box.getSize(new THREE.Vector3()));
                console.log('Center:', box.getCenter(new THREE.Vector3()));

                // OPTIONAL: BoxHelper in ROT zum Anzeigen im Viewport
                //const boxHelper = new THREE.BoxHelper(model, 0xff0000);
                //scene.add(boxHelper);
                if (loaderDiv) loaderDiv.style.display = 'none';
            },
            (xhr) => {
                let proc = (xhr.loaded / xhr.total * 100).toFixed(1);
                if (proc > 100) proc = 100;
                if (loaderDiv) loaderDiv.textContent = (proc < 100) ? `Geladen: ${proc}%` : `Init 3D...`;
            },
            (error) => {
                if (loaderDiv) loaderDiv.textContent = 'Fehler beim Laden: ' + error;
            }
        );

        // 4. Controls - erst aktivieren wenn alles geladen
        // 5. Animation loop
        const controls = new OrbitControls(camera, renderer.domElement);
        let easeCam = true;
        function animate() {
            if (modelscale !== undefined) {
                modelscale += 0.25 * (targetscale - modelscale); // ease to Size
                model.scale.setScalar(modelscale);
                const distance = camera.position.distanceTo(camTarget);
                if (easeCam == true) {
                    camera.position.x += 0.1 * (camTarget.x - camera.position.x); // ease Camera
                    camera.position.y += 0.1 * (camTarget.y - camera.position.y);
                    camera.position.z += 0.1 * (camTarget.z - camera.position.z);
                    if (distance < 0.01) {  // Ab jetzt Auto-Rotate
                        easeCam = false;
                        controls.enableDamping = true;
                        controls.autoRotate = true;
                        controls.autoRotateSpeed = 0.05;
                    }
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>