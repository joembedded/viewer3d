<!DOCTYPE html>
<!-- dieses kleine Tool laedt ein GLB Modell, umgibt es optional mit einer Box  -->
<!-- V1.0 (C)JoEmbedded -->
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>3D-Viewer</title>
    <style>
        body {
            background: #444141;
            color: #eee;
            font-family: sans-serif;
        }
    </style>

    <!-- 3D Magic starts here -->
    <style>
        .viewer {
            box-sizing: border-box;
            position: relative;
        }

        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 100%;
            background: rgba(52, 49, 95, 0.85);
            padding: 0.7em 1.2em;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@latest/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
				}
			}
	</script>
    <script type="module" defer>
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        export function view3d(containerId, modelFname, tscale = 1, loaderId = undefined) {
            const data3d = {
                container: document.getElementById(containerId),
                scene: new THREE.Scene()
            }
            // Funktion: Erzeuge einfarbiges Canvas Textur
            function createCanvasTexture(colorTop, colorBottom) {
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext('2d');
                // Farbverlauf (oben -> unten)
                const gradient = context.createLinearGradient(0, 0, 0, size);
                gradient.addColorStop(0, colorTop);
                gradient.addColorStop(1, colorBottom);
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                return new THREE.CanvasTexture(canvas);
            }
            const bkTexture = createCanvasTexture('#ffffff', '#202030');
            bkTexture.mapping = THREE.EquirectangularReflectionMapping;

            data3d.scene.environment = bkTexture;
            //data3d.scene.background = bkTexture; // kind of "Sky"
            data3d.scene.background = new THREE.Color(0x202028); // better

            data3d.camera = new THREE.PerspectiveCamera(30, data3d.container.clientWidth / data3d.container.clientHeight, 0.1, 1000);
            data3d.camera.position.set(0, 2, 0.5);
            data3d.renderer = new THREE.WebGLRenderer({ antialias: true });
            data3d.renderer.setPixelRatio(window.devicePixelRatio);
            //data3d.renderer.setSize(window.innerWidth, window.innerHeight); // variable size
            data3d.renderer.setSize(data3d.container.clientWidth - 2, data3d.container.clientHeight - 2);
            data3d.renderer.setAnimationLoop(animate);
            data3d.renderer.outputEncoding = THREE.sRGBEncoding;
            data3d.renderer.toneMappingExposure = 1.2;
            data3d.renderer.toneMapping = THREE.LinearToneMapping;
            data3d.container.appendChild(data3d.renderer.domElement);
            window.addEventListener('resize', () => {
                data3d.renderer.setSize(data3d.container.clientWidth, data3d.container.clientHeight);
                data3d.camera.aspect = data3d.container.clientWidth / data3d.container.clientHeight;
                data3d.camera.updateProjectionMatrix();
            });

            // GLTF/GLB laden
            data3d.modelscale = undefined; // set after full loaded!
            data3d.targetscale = tscale;
            const loader = new GLTFLoader();
            if (loaderId) {
                data3d.loaderDiv = document.getElementById(loaderId); // Loader per Model
                data3d.loaderDiv.textContent = 'Lade Modell...';
            }
            loader.load(
                modelFname,
                (gltf) => {
                    data3d.model = gltf.scene;

                    // Mittelpunkt berechnen und verschieben
                    const box = new THREE.Box3().setFromObject(data3d.model);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    data3d.model.position.sub(center);
                    // Modell skalieren, sodass es einigermassen den Viewer füllt
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const desiredSize = tscale; /* Default-Size fürs Test-Model, kann man noch optimieren */
                    data3d.targetscale = desiredSize / maxDim;
                    data3d.scene.add(data3d.model);
                    data3d.modelscale = Math.max(data3d.model.scale.x, data3d.model.scale.y, data3d.model.scale.z);
                    data3d.model.scale.setScalar(0.1);
                    data3d.modRotTarget = new THREE.Vector3(0, 0, 0);
                    data3d.model.rotation.set(3.14, 1.7, 0.8);

                    // Ausgabe Box in der Konsole
                    console.log('Model:', modelFname);
                    console.log('BoundingBox min:', box.min);
                    console.log('BoundingBox max:', box.max);
                    console.log('Size:', box.getSize(new THREE.Vector3()));
                    console.log('Center:', box.getCenter(new THREE.Vector3()));

                    // OPTIONAL: BoxHelper in ROT zum Anzeigen im Viewport
                    //const boxHelper = new THREE.BoxHelper(model, 0xff0000);
                    //scene.add(boxHelper);
                    if (data3d.loaderDiv) data3d.loaderDiv.style.display = 'none';
                },
                (xhr) => {
                    let proc = (xhr.loaded / xhr.total * 100).toFixed(1);
                    if (proc > 100) proc = 100;
                    if (data3d.loaderDiv) data3d.loaderDiv.textContent = (proc < 100) ? `Geladen: ${proc}%` : `Init 3D...`;
                },
                (error) => {
                    if (data3d.loaderDiv) data3d.loaderDiv.textContent = 'Fehler beim Laden: ' + error;
                }
            );
            //  Controls - erst aktivieren wenn alles geladen
            data3d.controls = new OrbitControls(data3d.camera, data3d.renderer.domElement);
            data3d.controls.enableDamping = true;
            data3d.controls.autoRotate = true;
            data3d.controls.autoRotateSpeed = 0.05;
            // Animation loop
            function animate() {
                if (data3d.modelscale !== undefined) {
                    data3d.modelscale += 0.25 * (data3d.targetscale - data3d.modelscale); // ease to Size
                    data3d.model.scale.setScalar(data3d.modelscale);
                    data3d.model.rotation.x += 0.15 * (data3d.modRotTarget.x - data3d.model.rotation.x); // and rotate
                    data3d.model.rotation.y += 0.12 * (data3d.modRotTarget.y - data3d.model.rotation.y);
                    data3d.model.rotation.z += 0.1 * (data3d.modRotTarget.z - data3d.model.rotation.z);
                }
                data3d.controls.update();
                data3d.renderer.render(data3d.scene, data3d.camera);
            }
            return data3d;
        }

        // Load was?
        view3d('mviewer', 'rak3172sip.glb', 1.3, 'mloader');
        view3d('vmini', 'rak3172sip.glb', 0.5, 'miniloader');
    </script>
    <!-- 3D Magic end -->


</head>

<body>
    <h2>3D-Viewer - JoEmbedded</h2>
    <div>Relative View1:</div>
    <div id="mviewer" class="viewer" style=" width: 90vW; height: 40vh;     border: 1px solid #ccc;">
        <div id="mloader" class="loader"></div>
    </div>
    <div>Fixed View2:</div>
    <div id="vmini" style=" width:300px; height:200px; border: 1px solid #F00;" class="viewer">
        <div id="miniloader" class="loader"></div>
    </div>
</body>

</html>