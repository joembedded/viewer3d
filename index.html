<!DOCTYPE html>
<!-- dieses kleine Tool laedt ein GLB Modell, umgibt es optional mit einer Box  -->
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>3D-Viewer</title>
    <style>
        #viewer {
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
        }

        #loader {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 200%;
            background: rgba(92, 91, 91, 0.9);
            padding: 1em 2em;
            border-radius: 8px;
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.3);
        }

        body {
            background: #222;
            color: #eee;
            font-family: sans-serif;
        }
    </style>
    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@latest/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
				}
			}
	</script>
</head>

<body>
    <h2>3D-Viewer - JoEmbedded</h2>
    <div id="loader">Lade Modell...</div>
    <div id="viewer"></div>

    <script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. Grundszene aufsetzen
        const container = document.getElementById('viewer');
        const scene = new THREE.Scene();

        scene.background = new THREE.Color(0x202028); // use Color Background
        new THREE.TextureLoader().load(
            'sky.jpg',
            function (bkTexture) {
                bkTexture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = bkTexture;
            });

        const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 2, 1);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        //renderer.setSize(window.innerWidth, window.innerHeight); // variable size
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setAnimationLoop(animate);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMappingExposure = 1.2;
        renderer.toneMapping = THREE.LinearToneMapping;

        container.appendChild(renderer.domElement);

        // 3. GLTF/GLB laden
        let model;
        let targetscale;
        let modelscale;
        const loader = new GLTFLoader();
        const loaderDiv = document.getElementById('loader');
        loader.load(
            'rak3172sip.glb',
            (gltf) => {
                model = gltf.scene;

                // Mittelpunkt berechnen und verschieben
                const box = new THREE.Box3().setFromObject(model);
                const center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center);
                // Modell skalieren, sodass es 90% des Viewers fÃ¼llt
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const desiredSize = 1.3;
                targetscale = desiredSize / maxDim;
                scene.add(model);
                modelscale = Math.max(model.scale.x, model.scale.y, model.scale.z);

                // Ausgabe Box in der Konsole
                console.log('BoundingBox min:', box.min);
                console.log('BoundingBox max:', box.max);
                console.log('Size:', box.getSize(new THREE.Vector3()));
                console.log('Center:', box.getCenter(new THREE.Vector3()));

                // OPTIONAL: BoxHelper in ROT zum Anzeigen im Viewport
                //const boxHelper = new THREE.BoxHelper(model, 0xff0000);
                //scene.add(boxHelper);

                if (loaderDiv) loaderDiv.style.display = 'none';
            },
            (xhr) => {
                const proc = (xhr.loaded / xhr.total * 100).toFixed(1);
                console.log(`Geladen: ${proc}%`);
                if (loaderDiv) loaderDiv.textContent = `Geladen: ${proc}%`;
            },
            (error) => {
                console.error('Fehler beim Laden:', error);
                if (loaderDiv) loaderDiv.textContent = 'Fehler beim Laden: ' + error;
            }
        );

        // 4. Controls - erst aktivieren wenn alles geladen
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.1;
        // 5. Animation loop
        function animate() {
            if (modelscale !== undefined) {
                const ds = targetscale - modelscale;
                modelscale += 0.25 * ds;
                model.scale.setScalar(modelscale);
            }
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>